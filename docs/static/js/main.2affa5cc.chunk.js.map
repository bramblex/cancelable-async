{"version":3,"sources":["serviceWorker.ts","index.tsx","App.tsx","cancelable-async.ts"],"names":["Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message","defaultValue","useState","content","setContent","finalCode","setFinalCode","cancelRef","useRef","logs","setLogs","value","onChange","ev","target","style","width","marginLeft","height","onClick","a","log","contents","old","concat","funcCode","cancelable","eval","func","cancel","current","map","i","key","node","ast","acorn","toString","body","estraverse","replace","enter","test","type","VisitorOption","Skip","leave","callee","name","arguments","astring"],"mappings":"8OAYoBA,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAACC,EAAA,EAAD,OAEFC,SAASC,eAAe,SDiIpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,a,09BE9ItBC,aAAY,sHAOlB,SAASb,MAAO,IAAD,UACiBc,oDAASD,cAD1B,8JACNE,QADM,cACGC,WADH,yBAEqBF,oDAAS,IAF9B,+JAENG,UAFM,cAEKC,aAFL,cAGPC,UAAYC,oDAHL,WAIWN,oDAAmB,IAJ9B,+JAINO,KAJM,cAIAC,QAJA,cAMb,OACE,sEACE,yFACA,sEACA,wFACA,sEACG,qBACD,uEACEC,MAAOR,QACPS,SAAU,SAAAC,GAAE,OAAIT,WAAWS,EAAGC,OAAOH,QACrCI,MAAO,CACLC,MAAO,mBACPC,WAAY,MACZC,OAAQ,WAGX,KAEH,sEACE,qEACEC,QAAO,uQAAE,8LAAAC,EAAA,2FACPV,QAAQ,IACFX,QAAU,CACdsB,IADc,WACc,IAAD,uBAApBC,EAAoB,yBAApBA,EAAoB,gBACzBZ,SAAQ,SAAAa,GAAG,OAAIA,EAAIC,OAAOF,QAGxBG,SAAWC,yDAAW,+BAAD,OAAgCvB,QAAhC,OAE3BG,aAAamB,UATN,MAWgBE,KAAKF,UAXrB,sJAWAG,KAXA,UAWMC,OAXN,UAYPtB,UAAUuB,QAAUD,OAZb,gCAcCD,OAdD,OAeL7B,QAAQsB,IAAI,eAfP,8EAiBiB,WAAlB,YAAMrB,SACRD,QAAQsB,IAAI,kBAlBT,wEADX,OAwBA,qEACEF,QAAS,kBAAMZ,UAAUuB,SAAWvB,UAAUuB,YADhD,WAIF,uFACA,sEACGzB,WAEH,iFACA,sEACGI,KAAKsB,KAAI,SAACV,EAAKW,GAAN,OAAY,kEAAKC,IAAKD,GAAIX,QAM7BjC,2B,+BC3Ef,qEAkCO,SAASsC,EAA8CE,GAC1D7B,QAAQsB,IAAIO,GACZ,IA3BeM,EA2BTC,EAAMC,IAA4B,oBAATR,EAAsBA,EAAKS,WAAaT,EAAM,IAC7EO,EAAIG,KAAK,GAAGA,MA5BGJ,EA4BcC,EAAIG,KAAK,GAAGA,KA3BlCC,IAAWC,QAAQN,EAAM,CAC5BO,MAD4B,SACtBP,GACF,MAAI,YAAYQ,KAAKR,EAAKS,MACfJ,IAAWK,cAAcC,KAE7BX,GAEXY,MAP4B,SAOtBZ,GACF,MAAkB,oBAAdA,EAAKS,KACE,CACHA,KAAM,iBACNI,OAAQ,CACJJ,KAAM,aACNK,KAhBC,qBAkBLC,UAAW,CAACf,IAGbA,MAWf,IAAMT,EAAWyB,IAAiBf,GAAKK,QAAQ,QAAS,IACxD,MAAM,4BAAN,OAlCe,gBAkCf,mCAjCqB,oBAiCrB,iCAlCe,gBAkCf,mFAMUf,EANV,0BAlCe,gBAkCf,2B","file":"static/js/main.2affa5cc.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import React, { useState, useRef } from 'react';\nimport { cancelable } from './cancelable-async'\n\nconst defaultValue = `\nfor (let i=0; i < 10; i++) {\n  await (new Promise(resolve => setTimeout(resolve, 1e3)));\n  console.log(i);\n}\n`;\n\nfunction App() {\n  const [content, setContent] = useState(defaultValue);\n  const [finalCode, setFinalCode] = useState('');\n  const cancelRef = useRef<() => void>();\n  const [logs, setLogs] = useState<string[]>([]);\n\n  return (\n    <div>\n      <h1>Cancelable Async</h1>\n      <hr />\n      <h2>Async Function:</h2>\n      <div>\n        {'async function() {'}\n        <textarea\n          value={content}\n          onChange={ev => setContent(ev.target.value)}\n          style={{\n            width: 'calc(100% - 2em)',\n            marginLeft: '2em',\n            height: '200px',\n          }}\n        />\n        {'}'}\n      </div>\n      <div>\n        <button\n          onClick={async () => {\n            setLogs([]);\n            const console = {\n              log(...contents: string[]) {\n                setLogs(old => old.concat(contents));\n              }\n            };\n            const funcCode = cancelable(`async function __func__ (){ ${content} }`);\n\n            setFinalCode(funcCode);\n\n            const [func, cancel] = eval(funcCode);\n            cancelRef.current = cancel;\n            try {\n              await func();\n              console.log('=== End ===');\n            } catch (error) {\n              if (error.message === 'Cancel') {\n                console.log('=== Cancel ===');\n              }\n            }\n          }}\n        >Run</button>\n        <button\n          onClick={() => cancelRef.current && cancelRef.current()}\n        >Cancel</button>\n      </div>\n      <h2>Compiled Code:</h2>\n      <pre>\n        {finalCode}\n      </pre>\n      <h2>Console:</h2>\n      <div>\n        {logs.map((log, i) => <div key={i}>{log}</div>)}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import * as acorn from 'acorn';\nimport * as astring from 'astring';\nimport estraverse from 'estraverse';\n\nimport * as ESTree from 'estree';\n\nconst signalName = \"__$isCancel__\";\nconst shouldCancelName = \"__$shouldCancel__\";\n\nfunction transform(node: ESTree.Node) {\n    return estraverse.replace(node, {\n        enter(node) {\n            if (/function/i.test(node.type)) {\n                return estraverse.VisitorOption.Skip;\n            }\n            return node;\n        },\n        leave(node) {\n            if (node.type === \"AwaitExpression\") {\n                return {\n                    type: \"CallExpression\",\n                    callee: {\n                        type: \"Identifier\",\n                        name: shouldCancelName,\n                    },\n                    arguments: [node],\n                };\n            }\n            return node;\n        },\n    });\n}\n\n\nexport function cancelable<F extends (...args: any[]) => any>(func: F | string): string {\n    console.log(func);\n    const ast = acorn.parse(typeof func === 'function' ? func.toString() : func, {}) as any;\n    ast.body[0].body = transform(ast.body[0].body);\n\n    const funcCode = astring.generate(ast).replace(/;\\s*$/, \"\");\n    return `((function () {\n    var ${signalName} = false;\n    function ${shouldCancelName}(value) { \n      if (${signalName}) throw new Error('Cancel'); \n      return value;\n    };\n    return [${funcCode}, function (){ ${signalName} = true }];\n  })())`;\n}"],"sourceRoot":""}